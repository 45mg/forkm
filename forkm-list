#!/bin/sh
# TODO license etc

set -eu
. "${FORKM_PATH}"/forkm--util

show_help() {
    cat <<EOF
usage: forkm list

List all tracked patch branches.

Options:
-q, --quiet    no warnings or info messages
-o, --oneline  --quiet, and space-separated output
-v, --verbose  run with 'set -x'
-h, --help     show this message and exit
-V, --version  show version information and exit
EOF
}

branch_list=""
quiet=0
oneline=0
# Parse arguments
while [ $# -gt 0 ]; do
    case $1 in
        -h | --help)
            show_help
            exit 0
            ;;
        -V | --version)
            printf "forkm: version %s\n" "${FORKM_VERSION}"
            exit 0
            ;;
        -q | --quiet)
            quiet=1
            shift
            ;;
        -o | --oneline)
            oneline=1
            shift
            ;;
        -v | --verbose)
            set -x
            shift
            ;;
        -*) # Invalid options.
            util_error "Invalid flag '$1'"
            show_help
            exit 1
            ;;
        *)
            # We don't accept non-flags for this subcommand
            show_help
            exit 1
            ;;
    esac
done

format='%s'
if [ $oneline -ne 0 ]; then
    format="${format} "
else
    format="${format}"'\n'
fi

# list the target of every tracker.
for refpath in "${GIT_COMMON_DIR}"/refs/forkm/*; do
    # exit immediately if the glob doesn't expand (no refs)
    if [ "$refpath" = "${GIT_COMMON_DIR}/refs/forkm/*" ]; then
        exit 0
    fi
    ref="${refpath#"$GIT_COMMON_DIR"/}"
    branch="$(git symbolic-ref --short -- "$ref")"
    if [ -z "$(git branch --list -- "${branch}")" ]; then
        if [ $quiet -eq 0 ]; then
            util_warn "dangling tracker ${ref};"
            util_warn "did you delete the corresponding tracked branch?"
        fi
    else
        printf "${format}" "${branch}"
    fi
done
[ $oneline -ne 0 ] && printf '\n'
exit 0
